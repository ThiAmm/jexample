The Graph Object is a Singleton, it knows all the classes under test and all the TestMethod's.
A Graph has a Map of Method -> TestMethod to make sure, that one Method has only one TestMethod-Instance.
A Graph has a Set of TestClass, all the classes under test.

The Graph first validates the test methods and its dependencies, then it adds the TestClass to the list of classes under test, 
it adds all the testmethods to the map of testmethods, then it adds the dependencies to each of the testmethods.

Wrote a CycleDetector which works as follows:
first it searches all the bottom nodes, the nodes, which no other node has as a parent. then it iterates over all
bottom nodes, checks, if the node's childs were already processed and if the notVisited list is empty. if it is not empty and all
childs were processed, there is a cycle. otherwise it checks if a node was already visited, if not, it adds the node to the visited list and removes it from
the notVisited list. then it checks, if there is a node in the notVisited list, that has the node as a parent. if not, it
is added to the childProcessed list. then the same method is called for all the parents of the node. seems to work, at least the test 
is green ;-). (note: does not work, if not all nodes are known at the beginning, which is the case, if there are dependencies over
class boundaries)

DependencyParser: if the dependency is in another class than the called testclass, the parser gets the classname. if the classname 
is specified without package, the package of the testclass is taken, if there is a package specified, this package is taken.

DependencyValidator: tests also, if a method depends on itself. first it tests, if all dependencies are, themself, testmethods. then it tests,
if the method depends on itself, then it compares parameter types and return value types. if something is not ok, it returns a list
with all errors, that are thrown as InitializationError.

CycleDetector now works differentely: it simply saves all the edges it passes and if it passes an edge it has already passed once, there is
a cycle. simultaneously, it saves all the passed methods in a list and if there were no cycles, the list of methods is returned.

The Graph makes a cycle detection before it does anything else, when adding a class.

The MethodValidator gets a List of Methods instead of only the TestClass, because there could be from other classes, which wouldn't be
checked otherwise.

The TestMethod runs first its dependencies, if all dependencies were GREEN, it runs itself, if one of the dependencies failed or 
was skipped, it set its state to IGNORED and tells the RunNotifier that it was ignored.

Had to change the CycleDetector: only the Links for one traversation are saved, because if all the links are saved there are
cases for which it detects a cycle where there isn't one (A -> C, B -> C, C -> D).


12.10.2007
changed the type of the dependencies in testmethod from set to list, because the order of the dependencies is important, to get 
the return values of the parents, if a testmethod takes arguments

TestMethod: invoking the method is assigned to a variable returnValue of the class TestMethod. before invoking a method, the 
arguments it takes are checked, and the returnvalues from the parent methods are taken and passed to the method.