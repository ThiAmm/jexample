<HTML>
<HEAD>
<STYLE>
  body { background-color:buttonface; font: 10pt sans-serif; }
  h1 { font: bold 12pt sans-serif; }  
</STYLE>
</HEAD>
<BODY>
<P><B>JExample</B> is a small framework to write repeatable <i>and dependent</i> tests.
<P>
Dependent tests are not only more fun to write&mdash;they also run faster,
 reduce code duplication and provide better failure localization. How come?
 Given dependencies A, B and C had been executed successfully, 
 test T can reuse all of their fixtures.
 This saves both setup costs and code duplication.
 On the other hand, if one of the dependencies fails, test T and all its dependents are skipped. 
 This helps to pin-point failures to their very cause.
<!-- <P>
With JExample, testing complex scenarios is a bliss.
 There are always hidden dependencies that cannot be broken with isolated testing.
 Even something as simple as, for example, testing a <tt>Stack</tt> class includes hidden dependencies.
 You just cannot pop elements without first using the push functionality.
 Thus if <tt>push</tt> is broken, even an isolated <tt>testPop</tt> will fail.
 With JExample we can do better.
<PRE>
@RunWith(JExample.class)
public class StackTest {

    @Test
    public Stack emptyStack() {
        Stack stack = new Stack();
        assert stack.isEmpty();
        return stack;
    }

    @Test
    @Given("#emptyStack")
    public Stack testPush(Stack stack) {
        stack.push("element"):
        assert stack.size() == 1;
        return stack;
    }
    
    @Test 
    @Given("#testPush")
    public void testPop(Stack stack) {
        Object elem = stack.pop():
        assert elem.equals("element");
        assert stack.isEmpty();
    }
    
}    
</PRE>
With that code, <tt>testPop</tt> is only executed if <tt>testPush</tt> returns a valid example of a Stack instance. --> 
 
</BODY>